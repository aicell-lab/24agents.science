"""
Dataset Startup Script for 24agents.science

This script sets up an MCP (Model Context Protocol) service for a mounted dataset,
allowing AI agents to interact with the data through a standardized interface.
"""

import datetime
import json
import os
from typing import Any, Optional

# Environment variables set before this script runs:
# - DATASET_NAME: Name of the dataset
# - DATASET_DESCRIPTION: Description generated by AI
# - DATASET_ID: Unique identifier for the dataset
# - HYPHA_TOKEN: Authentication token


def get_dataset_info() -> dict:
    """Get dataset information from environment variables."""
    return {
        "name": os.environ.get("DATASET_NAME", "Unnamed Dataset"),
        "description": os.environ.get("DATASET_DESCRIPTION", "No description provided"),
        "id": os.environ.get("DATASET_ID", "unknown"),
        "data_path": "/data",
    }


def get_docs() -> str:
    """Get documentation about this dataset and how to interact with it."""
    info = get_dataset_info()
    return f"""# {info['name']}

{info['description']}

## Available Functions

- `run_python(code)` - Execute Python code with access to the dataset
- `get_docs()` - Get this documentation

## Data Location
All data files are mounted at `/data`. Use relative paths from this directory.

## Example Usage
```python
# List all files
import os
files = os.listdir("/data")

# Read a CSV file
import pandas as pd
df = pd.read_csv("/data/myfile.csv")

# Process an image
from PIL import Image
img = Image.open("/data/images/sample.png")
```
"""


# Global namespace for code execution
_execution_namespace: dict = {}


def run_python(code: str, context: Optional[dict] = None) -> Any:
    """
    Execute Python code with access to the dataset.

    The code runs in a persistent namespace, so variables defined
    in one call are available in subsequent calls.

    Args:
        code: Python code to execute
        context: Optional dictionary of variables to add to the namespace

    Returns:
        The result of the last expression, or None
    """
    global _execution_namespace

    # Add context variables if provided
    if context:
        _execution_namespace.update(context)

    # Ensure common imports are available
    if "os" not in _execution_namespace:
        import os

        _execution_namespace["os"] = os

    if "sys" not in _execution_namespace:
        import sys

        _execution_namespace["sys"] = sys

    # Set the data path in the namespace
    _execution_namespace["DATA_PATH"] = "/data"

    # Execute the code
    try:
        # Try to evaluate as an expression first
        result = eval(code, _execution_namespace)
        return result
    except SyntaxError:
        # If it's not an expression, execute as statements
        exec(code, _execution_namespace)
        return None


async def setup_mcp_service():
    """Set up the MCP service for this dataset."""
    from hypha_rpc import connect_to_server

    # Get configuration from environment
    dataset_id = os.environ.get("DATASET_ID", "unknown")
    token = os.environ.get("HYPHA_TOKEN", "")

    # Connect to Hypha server
    server = await connect_to_server(
        {"server_url": "https://hypha.aicell.io", "token": token}
    )

    # Define the service interface
    service_id = f"{dataset_id}-service"

    async def log_request(
        request_id: str,
        method: str,
        status: str,
        message: str = "",
        detail: str = "",
        user: Any = None,
    ):
        """Log a request event to Hypha."""
        try:
            event_type = f"dataset_request_{dataset_id}"
            await server.log_event(
                event_type,
                {
                    "id": request_id,
                    "timestamp": datetime.datetime.now().isoformat(),
                    "method": method,
                    "status": status,
                    "message": message,
                    "detail": detail,
                    "user": user,
                },
            )
        except Exception as e:
            print(f"Failed to log request: {e}")

    # MCP service methods
    async def mcp_run_python(code: str, context: dict | None = None) -> Any:
        import uuid

        request_id = str(uuid.uuid4())
        user = context.get("user") if context else None

        # Log the code being executed
        print(
            f"::REQ::{json.dumps({'id': request_id, 'timestamp': datetime.datetime.now().isoformat(), 'method': 'run_python', 'status': 'processing', 'message': 'Executing Python code', 'detail': code, 'user': user})}"
        )

        await log_request(
            request_id,
            "run_python",
            "processing",
            "Executing Python code",
            detail=code,
            user=user,
        )
        try:
            result = run_python(code)
            result_str = str(result) if result is not None else "None"

            print(
                f"::REQ::{json.dumps({'id': request_id, 'timestamp': datetime.datetime.now().isoformat(), 'method': 'run_python', 'status': 'completed', 'message': 'Execution completed', 'detail': result_str[:1000], 'user': user})}"
            )

            await log_request(
                request_id,
                "run_python",
                "completed",
                "Execution completed",
                detail=result_str[:1000],
                user=user,
            )
            return result
        except Exception as e:
            error_msg = str(e)
            print(
                f"::REQ::{json.dumps({'id': request_id, 'timestamp': datetime.datetime.now().isoformat(), 'method': 'run_python', 'status': 'error', 'message': error_msg, 'user': user})}"
            )

            await log_request(request_id, "run_python", "error", error_msg, user=user)
            raise

    async def mcp_get_docs(context: dict | None = None) -> str:
        return get_docs()

    # Register the service with only run_python and get_docs
    # File listing/reading is done in the frontend since the dataset folder is accessible there
    service_info = await server.register_service(
        {
            "id": service_id,
            "name": f"Dataset: {os.environ.get('DATASET_NAME', 'Unknown')}",
            "description": get_docs(),
            "config": {"visibility": "public", "require_context": True},
            "run_python": mcp_run_python,
            "get_docs": mcp_get_docs,
        }
    )

    print(f"Registered MCP service with ID: {service_id}")
    print(f"Service info: {service_info}")

    return service_info


# Main execution
if __name__ == "__main__":
    import asyncio

    print("Starting dataset service setup...")
    print(f"Dataset: {os.environ.get('DATASET_NAME', 'Unknown')}")
    print(f"Dataset ID: {os.environ.get('DATASET_ID', 'Unknown')}")

    # Run the async setup
    asyncio.get_event_loop().run_until_complete(setup_mcp_service())

    # Keep the service running
    print("Dataset service is running. Press Ctrl+C to stop.")
    try:
        asyncio.get_event_loop().run_forever()
    except KeyboardInterrupt:
        print("Shutting down dataset service...")
